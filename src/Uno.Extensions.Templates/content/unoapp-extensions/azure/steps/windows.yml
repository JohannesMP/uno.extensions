parameters:
- name: major
  type: string
  default: '0'  
- name: minor
  type: string
  default: '0'
- name: package_id
  type: string
  default: 'release_Windows'
- name: project_to_build
  type: string
  default: '' 
- name: project_folder
  type: string
  default: ''            
- name: project_platform
  type: string
  default: 'x86'  
  # *** [REQUIRED FOR GENERATING SIGNED .MSIX PACKAGE] ***
  #For Creating a valid PFX certificate for signing:
  # 1.- Open VisualStudio and create a new empty Windows Universal project
  # 2.- Open solution explorer and double click on Package.appxmanifest file 
  # 3.- Now you should see a bunch of tabs. Select the last one (Packaging)
  # 4.- Fill the editor field and click on "Select Certificate" and a new popup should open
  # 5.- Click on "Create" and a second popup should open
  # 6.- Make sure the "Editor Name" field is correct and DO NOT put any password
  # 7.- Scroll down and click on "Ok" and second popup will close
  # 8.- Click on "Ok" again. At this point you should see in solution explorer the new certificate: "TemporaryKey.pfx"
  # 9.- Last part consists in uploading the new pfx certificate to your pipeline secure storage. See more details here: https://learn.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops
- name: certificate
  type: string
  default: ''       
- name: sign_package
  type: string
  default: 'false'
- name: publish_artifacts
  type: string
  default: 'true'    
- name: compress_artifacts
  type: string
  default: 'true'      

steps:
    #Validate required parameters before executing any other script
    - task: PowerShell@2
      displayName: 'Verify required parameters'
      inputs:
        targetType: 'inline'
        script: |
            $errors = ''
            if ('' -eq '${{ parameters.project_to_build }}') { $errors = $errors + '[project_to_build] is not valid.' + "`r`n"  }
            if ('true' -eq '${{ parameters.sign_package }}'){
              if ('' -eq '${{ parameters.certificate }}') { $errors = $errors + '[certificate] is not valid. Please make sure the name of the .pfx certificate is correct and it exists in secure files' + "`r`n"  }
            }

            if (-not ([string]::IsNullOrEmpty($errors))){
                $errors
                throw "Some required parameters are missing"
            }

    - task: DownloadSecureFile@1
      name: keyStore
      displayName: "Download .pfx from secure files"
      condition:  eq('${{ parameters.sign_package }}', 'true')
      inputs:
        secureFile: ${{ parameters.certificate }}

    # Compile Mobile
    - task: PowerShell@2
      displayName: 'Build and Package'
      inputs:
        targetType: 'inline'
        script: |
            $projectFolder = '${{ parameters.project_folder }}'
            if (('' -eq $projectFolder) -and ("${{ parameters.project_to_build }}".Contains('/') )){
              Write-Host "Adjusting proj folder"
              $projectFolder = "${{ parameters.project_to_build }}".SubString(0, "${{ parameters.project_to_build }}".LastIndexOf('/'))
            }
            Write-Host "Current proj folder is: $projectFolder"

            choco install vswhere
            $path = vswhere -latest -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe | select-object -first 1

            & $path /t:Restore ${{ parameters.project_to_build }} /p:Configuration=Release /p:Platform=${{ parameters.project_platform }}
            if ('true' -eq '${{ parameters.sign_package }}') {
              & $path ${{ parameters.project_to_build }} /p:Configuration=Release /p:Platform=${{ parameters.project_platform }} /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundle=Never /p:PackageCertificateKeyFile=$(keyStore.secureFilePath) /p:AppxPackageDir=".\bin\Release\" /p:GenerateAppxPackageOnBuild=true
            }else{
              & $path ${{ parameters.project_to_build }} /p:AppxPackageSigningEnabled=false /p:Configuration=Release /p:Platform=${{ parameters.project_platform }}  /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundle=Never /p:AppxPackageDir=".\bin\Release\" /p:GenerateAppxPackageOnBuild=true
            }

            $finalPackageFolder = ".\artifacts"
            Write-Host "Creating package folder: $finalPackageFolder"
            New-Item -ItemType Directory -Force -Path $finalPackageFolder

            if ('true' -eq '${{ parameters.publish_artifacts }}') {
              if ('true' -eq '${{ parameters.compress_artifacts }}') {
                Write-Host "Compressing final package"
                $finalPackageName = "$finalPackageFolder\${{ parameters.package_id }}(${{ parameters.project_platform }})_${{parameters.major}}.${{parameters.minor}}.$(Build.BuildNumber).zip"
                Compress-Archive -Path "$projectFolder\bin\Release\*" -DestinationPath $finalPackageName
              }else{
                Copy-Item -Path "$projectFolder\bin\Release\*" -Destination ".\artifacts" -recurse -Force  
              }
            }

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Artifact'
      condition:  eq('${{ parameters.publish_artifacts }}', 'true')
      inputs:
        targetPath: .\artifacts
        artifactName: ${{ parameters.package_id }}(${{ parameters.project_platform }})_${{parameters.major}}.${{parameters.minor}}.$(Build.BuildNumber)
    